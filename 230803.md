## 부분집합(Subset sum)
### 부분집합의 수
- 집합의 원소가 n개 일 때, 공집합을 포함한 부분집합의 수는 2^n개 이다.
- 이는 각 원소를 부분집합에 포함시키거나 포함시키지 않는 2가지 경우를 모든 원소에 적용한 경우의 수와 같다.
- ex) {1,2,3,4} -> 2x2x2x2 =16가지
### 부분집합 생성하기
```
bit = [0, 0, 0, 0]
for i in range(2) :
    bit[0] = i                  #0번 원소
    for j in range(2):
        bit[1] = j
        for k in range(2):
            bit[2] = k
            for l in range(2):
                bit[3] = 1
                print_subset(bit) #생성된 부분집합 출력
```

## 비트 연산자
### 비트연산자
- & 비트 단위로 AND 연산을 한다.
- | 비트 단위로 or 연산을 한다.
- << 피연산자의 비트 열을 왼쪽으로 이동시킨다.
- \>> 피연산자의 비트 열을 오른쪽으로 이동시킨다.
### << 연산자
- 1 << n : 2^n 즉, 원소가 n 개일 경우의 모든 부분집합의 수를 의미한다.
### & 연산자
- i & (1 \<< j ) : i의 j번째 비트가 1인지 아닌지를 검사한다.  `if bit[i]`를 대신해줌

### 보다 간결하게 부분집합을 생성하는 방법
```py

# arr = [3, 6, 7, 1, 5, 4]
arr = [1, 2, 3]

n = len(arr)  # n : 원소의 개수

for i in range(1 << n):     # 1<<n :부분 집합의 개수
    for j in range(n):      # 원소의 수만큼 비트를 비교함
        if i & (1<<j):      # i의 j번 비트가 1인 경우
            print(arr[j], end = ", ")       # j번 원소 출력
    print()
print()
#1, 
#2, 
#1, 2, 
#3, 
#1, 3, 
#2, 3, 
#1, 2, 3, 
```
# 검색(search)

## 순차검색(Sequential Search)
### 일렬로 
### 정렬되어 있지 않은 경우
 - 찾고자 하는 원소의 순서에 따라 비교회수가 결정됨
  - 첫번째 원소를 찾을 때는 1번 비교, 두번째 원소를 찾을 때는 2번 비교.
  - 정렬되지 않은 자료에서의 순차검색의 평균 비교 회수
    - = (1/n) *

### 정렬되어 있는 경우
#### 검색 과정
- 자료가 오름차순으로 정렬 된 상태에서 검색을 실시한다고 가정하자.
- 실패하는 경우 평균 검색량이 성공하는 경우 평균 검색량과 같다.
## 이진 검색(Binary Search)(!!중요!!)
 #### - 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법
 - 목적키를 찾을 때 까지 이진 검색을 순환적으로 반복 수행함으로써 검색 범위를 반으로 줄여가면서 보다 빠르게 검색을 수행함
#### 이진검색을 위해 자료가 정리되어 있는 상태여야 한다. (**항상 정렬상태**)
### 검색 과정
- 자료의 중앙에 있는 원소를 고른다. 
- 중앙 원소의 값과 찾고자 하는 목표값을 비교한다.
- 목표값이 중앙 원소의 값보다 작으면 자료의 왼쪽 반에 대해서 새로 검색을 수행하고, 크다면 자료의 오른쪽 반에 대해서 새로 검색을 수행한다.
- 찾고자 하는 값을 찾을 때 까지 1-3 과정을 반복한다.
- 이진탐색 그림 기억하기/
### 구현
- 검색 범위의 시작점과 종료점을 이용하여 검색을 반복 수행한다.
- 이진 검색의 경우, 자료에 삽입이나 삭제가 발생했을 때 배열의 상태를 항상 정렬상태로 유지하는 추가 작업이 필요하다.
- 검색 후 재검색 시 스타트 지점부터 확인 후 설정 해주기
- start와 end 가 같더라도 똑같은 작업을 해줘야함.
- `start <= end` -> `=`꼭 포함시켜주기
- 탐색구간이 존재하면, 원소가 한 개 이상이면 무조건 탐색을 실시해야함.
- 키값에 대입하여 찾을때까지 반복하고 값을 찾지 못하면 false를 반환하기
```py
def binarySearch(a, N, key)
      start = 0
      end = N-1
      while start <= end : #탐색구간이 존재하면, 원소가 한개 이상이면 무조건 탐색을 실시해야함
            middle = (start + end) // 2
            if a[middle] == key : # 검색성공
                  return true
            elif a [middle] > key:
                  end = middle - 1
            else :
                  start = middle + 1
      return False                # 검색 실패
```
## 선택 정렬(Selection Sort)(!!중요!!)
- 버블정렬과 꼭 구별하기!! 
  - 정렬하면서 값을 비교하여 
- 선택정렬은 가장 작은(ex)값을 선택하여 앞으로 보내고 나머지 값들 중 또 작은 값을 찾아서 앞으로 보내는 방식이다
- 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식
  - 앞서 살펴본 셀렉션 알고리즘을 전체 자료에 적용한 것이다.
### 정렬 과정
  1. 주어진 리스트 중에서 최소값을 찾는다.
      - min_idx에 값을 넣어가며 비교함
  2. 리스트의 맨 앞에 위치한 값과 교환한다.
### 알고리즘
```
def SelctionSort(a[], n)
      for i from 0 to n-2
            a[i], ..., a[n-1] 원소 중 최소값 a[k] 찾음
            a[i] 와 [k] 교환
```
### 구현
```py
def selectionSort(a, N):
    for i in range(N-1):
        minIdx  i
        for j in range(i+1, N) :
            if a[minIdx] > a[j] :
                minIdx = j
        a[i], a[minIdx] = a[minIdx], a[i]

```
## 셀렉션 알고리즘(Selection Algorithm)
- 저장되어 있는 자료로 부터 k번째로 큰 혹은 작은 원소를 찾는 방법을 셀렉션 알고지름이라 한다.
  - 최소값, 최대값 혹은 중간값을 찾는 알고리즘을 의미하기도 한다.
- 선택 과정
  - 셀렉션은 아래와 같은 과정을 통해 이루어진다.
    - 정렬 알고리즘을 이용하여 자료 정렬하기
    - 원하는 순서에 있는 원소 가져오기