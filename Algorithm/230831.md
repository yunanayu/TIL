## 조합
#### 서로 다른 n개의 원소 중 r개를 순서없이 골라낸 것을 조합 (combination) 이라고 부른다.
### 재귀적 표현
nCr = n-1Cr-1 + n-1Cr<br>
nC0 = 1
### 재귀 호출을 이용한 조합 생성 알고리즘
```
an [] : n개의 원소를 가지고 있는 배열
tr [] : r개의 크기의 배열, 조합이 임시 저장될 배열

comb(n, r)
        if (r == 0) print_arr()
        else if (n < r) return
        else
                tr[r-1] = an[n-1]
                comb(n-1, r-1)
                comb(n-1 , r)
```
### 10개의 원소 중 3개를 고르는 조합
- i < j < k 라고 하면
```
for i : 0 -> 7      # j, k로 선택 될 원소를 남김
        for j : i+1 -> 8        # k로 선택 될 원소를 남김
                for k : j+1 -> 9
                        f(a[i], a[j], a[k])
```
### n개에서 r개를 고르는 조합(재귀)
```
def nCr(n,r,c): # n개에서 r개를 고르는 조합, s 선택할 수 있는 구간의 시작
    if r == 0:
        print(*comb)
    else:
        for i in range(s, n-r+1):
            comb[r-1] = A[i]
            nCr(n, r-1, i+1)
```
## 탐욕(Greedy) 알고리즘
- 탐욕 알고리즘은 최적해를 구하는데 사용되는 근시안적인 방법
- 일반적으로 머리속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근이 된다.
- 여러 경우 중 하나를 선택할 때 마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.
- 각 선택 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택을 계속 수집하여 최종적인 해답을 만들었다고 하여, **그것이 최적이라는 보장은 없다.**
### 탐욕 알고리즘의 동작 과정
1. 해 선택
    - 현재 상태게어 부분문제의 최적 해를 구한 뒤, 이를 부분해집합(solution set)에 추가한다.
2. 실행 가능성 검사
    - 새로운 부분 해 집합이 실행가능한지를 확인한다. 곧, 문제의 제약 조건을 위반하지 않는 지를 검사한다.
3. 해 검사
    - 새로운 부분 해 집합이 문제의 해가 되는지를 확인한다. 아직 전체 문제의 해가 완성되지 않았다면 1의 해 선택부터 다시 시작한다.

## 활동 선택(Activity-selection problem) 문제
### 탐욕 기법을 적용한 반복 알고리즘
```
A: 활동들의 집합. S: 선택된 활동(회의)들 집합
si:시작시간, fi:종료시간, 1<=i<=n
sort A by finish time
S <- {A1}
j <- 1
for i in 2 -> n
        if si > fj
                    s <- S U {Ai}
                    j <- i
```
## 탐욕 알고리즘의 필수 요소
### 탐