# 백트래킹

## 백트래킹 개념
- 여러가지 선택지(옵션)들이 존재하는 상황에서 한가지를 선택한다.
- 선택이 이루어지면 새로운 선택지들의 집합이 생성된다.
- 이런 선택을 반복하면서 최종상태에 도달한다.
  - 올바른 선택을 계속 하면 목표상태에 도달한다.
  
### 백트래킹과 깊이 우선 탐색과의 차이
- 어떤 노드에서 출발하는 경로가 해결책으로 이어질것같지 않으면 더 이상 그 경로를 따라가지 않음으로써 시도의 횟수를 줄임.(Prunning 가지치기)
- 깊이 우선 탐색이 모든 경로를 추적하는데 비해 백트래킹은 불필요한 경로를 조기에 차단
- 깊이 우선 탐색을 가하기에는 경우의 수가 너무나 많음. 즉, N!가지의 경우의 수를 가진 문제에 대해 깊이 우선 탐색을 가하면 당연히 처리 불가능한 문제.
- 백트레킹 알고리즘을 적용하면 일반적으로 경우의 수가 줄어들지만 이 역시 최악의 경우에는 여전히 지수함수 시간 (Exponential Time)을 요하므로 처리 불가능.

```py
# {1, 2, 3} 집합에서 3개의 숫자를 선택하는 기본적인 예제
# 이미 사용한 숫자는
arr = [i for i in range(1,4)]
path = [0] * 3

def backtracking(cnt):
    # 기저조건
    # 숫자 3개 골랐을 때 종료
    if cnt == 3:
        print(*path)
        return

    for num in arr:
        # 가지치기 - 중복된 숫자 제거
        # 조건을 작성하는것이 핵심
        if num in path:
            continue
        # 들어가기 전 로직 - 경로저장
        path[cnt] = num
        # 다음 재귀 함수 호출
        backtracking(cnt+1)
        # 돌아와서 할 로직 - 초기화
        path[cnt] = 0

backtracking(0)
'''
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
'''

```

### 백트래킹을 이용한 알고리즘 절차
1. 상태 공간 트리의 깊이 우선 검색을 실시한다.
2. 각 노드가 유망한지를 점검한다.
3. 만일 그 노드가 유망하지 않으면, 그 노드의 부모 노드로 돌아가서 검색을 계속한다.


# 트리
## 트리
싸이클이 없는 무향 연결 그래프
- 두 노드(or 정점) 사이에는 유일한 경로가 존재한다.
- 각 노드는 최대 하나의 부모 노드가 존재할 수 있다.
- 각 노드는 자식 노드가 없거나 하나 이상이 존재할 수 있다.


비선형 구조
- 원소들 간에 1:n 관계를 가지는 자료구조
- 원소들 간에 계층 관계를 가지는 계층형 자료구조


-사이클이 없는 그래프

## 이진트리
자녀 노드가 둘 이하인 트리

### 이진 트리 종류
- 완전 이진 트리
  - 마지막 레벨을 제외한 모든 레벨은 꽉 차있어야 한다.
  - 마지막 레벨 노드는 왼쪽부터 채워져야한다.
- 포화 이진 트리
  - 모든 레벨이 꽉 차있는 것

### 순회방법
### 트리 저장 방법


## 이진 탐색 트리
- 탐색작업을 효율적으로 하기 위한 자료구조
- 모든 원소는 서로 다른 키를 갖는다
- Key(왼쪽 서브 트리) <kye(루트 노드) < key(오른쪽 서브 트리)
- 중외 순회 시 오름차순으로 정렬 된 값을 얻는다